# # Ergasia2_E18138
• Δημιουργία Χρήστη)

Κάνουμε αναζήτηση στη βάση την ύπαρξη ενός χρήστη με το δεδομένο email και αποθηκεύουμε τα αποτελέσματα μας στην μεταβλητή userEx. Αν η μεταβλητή userEx είναι κενή, ο χρήστης δεν υπάρχει οπότε αποθηκεύουμε στη μεταβλητή user το email, το name, το password και την category  που μας δόθηκαν από το JSON data καθώς και ορίζουμε και το κενό orderHistory που θα περιέχει τις προηγούμενες παραγγελίες του χρήστη και κάνουμε εισαγωγή τους στο collection users το οποίο αν δεν έχει ήδη αποθηκευμένα δεδομένα , δημιουργείται αυτόματα. Στην επιτυχής εισαγωγή του χρήστη επιστρέφεται μήνυμα εισαγωγής του στην βάση. Αν ο χρήστης υπάρχει ήδη στη βάση, επιστρέφεται μήνυμα λάθους ότι ο χρήστης ήδη υπάρχει.Στην περίπτωση μη αποδεκτής εισαγωγής δεδομένων απο τον χρήστη επιστρέφεται ανάλογο μήνυμα.


• Login στο Σύστημα)
Κάνουμε αναζήτηση στη βάση για την ύπαρξη ενός χρήστη με το δεδομένο email.Αν υπάρχει  και password είναι ίδιο ίδιο με το αντίστοιχο στην βάση, τότε καλούμε τη συνάρτηση create_session με παράμετρο το email του χρήστη και αποθηκεύουμε στην μεταβλητή user_uuid το κωδικό με τον οποίο θα γίνεται η αυθεντικοποίηση του όσο είναι ενεργή η συνοδός. Στο dictionary res αποθηκεύουμε το user_uuid ως uuid και το email του ως email και το επιστρέφουμε στον χρήστη σε μορφή json.Μήνυμα λάθους εμφανίζεται επίσης στην περίπτωση που το δεδομένο password η email δεν είναι ίδιο με το αντίστοιχο στην βάση μας.Στην περίπτωση μη αποδεκτής εισαγωγής δεδομένων απο τον χρήστη επιστρέφεται ανάλογο μήνυμα.


• Αναζήτηση Προιόντος) Εξετάζουμε αν υπάρχουν τα στοιχεία name,category η ID στα δεδομένα του χρήστη.Στην περίπτωση μη αποδεκτής εισαγωγής δεδομένων απο τον χρήστη επιστρέφεται ανάλογο μήνυμα.Κάνουμε αναζήτηση στη βάση για την ύπαρξη ενός προιόντος με το δεδομένο name ή category ή ID που μας δώθηκε  και αποθηκεύουμε τα αποτελέσματα μας στην μεταβλητή pro. Αν το προιόν δεν υπάρχει τότε εμφανίζεται μήνυμα λάθους. Για κάθε προιόν που βρήκαμε στη βάση, αποθηκέυουμε στη λίστα pro2 τα αποτελέσματα τα οποία εμφανιζονται ύστερα στον χρήστη.Στην περίπτωση μη αποδεκτής εισαγωγής δεδομένων απο τον χρήστη επιστρέφεται ανάλογο μήνυμα.




• Προσθήκη προϊοντος στην Βάση)
Αποθηκεύουμε στην μεταβλητή uid τον κωδικό της συνοδού ο οποίος μας δίνεται από το JSON data ως header και καλούμε τη συνάρτηση is_session_valid με παράμετρο την μεταβλητή uid η οποία ελέγχει αν η συνοδός είναι έγκυρη. Αν είναι έγκυρη, κάνουμε αναζήτηση στην βάση για να βρούμε την κατηγορία του χρήστη.Αν η συνοδός δεν είναι έγκυρη, επιστρέφεται στον χρήστη μήνυμα λάθους.Αν ο χρήστης δεν είναι διαχειριστής τότε επιστρέφεται το ανάλογο μήνυμα λάθους.Κάνουμε αναζήτηση στη βάση για την ύπαρξη του προιόντος βάσει ID και αν δεν υπάρχει τοτε αποθηκεύουμε στην μεταβλητή product τα στοιχεία του προιόντος(name,price,description,category,stock,ID) και κάνουμε εισαγωγή του προιόντος επιστρέφοντας μήνυμα επιτυχίας στον χρήστη. Στην περίπτωση που ήδη υπάρχει, εμφανίζεται μήνυμα λάθους. Αν υπάρχουν , επιστρέφονται στον χρήστη σε μορφή json. Τέλος, στην περίπτωση μη αποδεκτής εισαγωγής δεδομένων απο τον χρήστη επιστρέφεται ανάλογο μήνυμα.

• Διαγραφή προιόντος από την βάση)

Αποθηκεύουμε στην μεταβλητή uid τον κωδικό της συνοδού ο οποίος μας δίνεται από το JSON data ως header και καλούμε τη συνάρτηση is_session_valid με παράμετρο την μεταβλητή uid η οποία ελέγχει αν η συνοδός είναι έγκυρη. Αν είναι έγκυρη, κάνουμε αναζήτηση στην βάση για να βρούμε την κατηγορία του χρήστη.Αν η συνοδός δεν είναι έγκυρη, επιστρέφεται στον χρήστη μήνυμα λάθους.Αν ο χρήστης δεν είναι διαχειριστής τότε επιστρέφεται το ανάλογο μήνυμα λάθους.Κάνουμε αναζήτηση στη βάση για την ύπαρξη του προιόντος βάσει ID και αν δεν υπάρχει τοτε εμφανίζεται μήνυμα λάθους. Αν υπάρχει τότε το γίνεται η διαγραφή του προιόντος απο τη βάση και εφμανίζεται μήνυμα επιτυχής διαγραφής.Τέλος, στην περίπτωση μη αποδεκτής εισαγωγής δεδομένων απο τον χρήστη επιστρέφεται ανάλογο μήνυμα.

• Ενημέρωση προϊοντος στην Βάση)

Αποθηκεύουμε στην μεταβλητή uid τον κωδικό της συνοδού ο οποίος μας δίνεται από το JSON data ως header και καλούμε τη συνάρτηση is_session_valid με παράμετρο την μεταβλητή uid η οποία ελέγχει αν η συνοδός είναι έγκυρη. Αν είναι έγκυρη, κάνουμε αναζήτηση στην βάση για να βρούμε την κατηγορία του χρήστη.Αν η συνοδός δεν είναι έγκυρη, επιστρέφεται στον χρήστη μήνυμα λάθους.Αν ο χρήστης δεν είναι διαχειριστής τότε επιστρέφεται το ανάλογο μήνυμα λάθους.Κάνουμε αναζήτηση στη βάση για την ύπαρξη του προιόντος βάσει ID και αν δεν υπάρχει τοτε εμφανίζεται μήνυμα λάθους. Αν υπάρχει τότε ανάλογα με τα επιθυμητά πεδίά που έχει εισάγει ο διαχειριστλής ως προς την ενημέρωση του προιόντος (name-price-description-stock) γίνεται η αντίστοιχη ενημέρωση στη βάση.Τέλος, στην περίπτωση μη αποδεκτής εισαγωγής δεδομένων απο τον χρήστη επιστρέφεται ανάλογο μήνυμα.


• Προσθήκη προϊοντος στo καλάθι χρήστη) 

Αποθηκεύουμε στην μεταβλητή uid τον κωδικό της συνοδού ο οποίος μας δίνεται από το JSON data ως header και καλούμε τη συνάρτηση is_session_valid με παράμετρο την μεταβλητή uid η οποία ελέγχει αν η συνοδός είναι έγκυρη.Αν η συνοδός δεν είναι έγκυρη, επιστρέφεται στον χρήστη μήνυμα λάθους.Αν είναι έγκυρη, κάνουμε αναζήτηση στην βάση για να βρούμε το προϊόν του χρήστη βάσει ID και αν δεν υπάρχει τοτε εμφανίζεται μήνυμα λάθους. Αν υπάρχει τότε εξετάζουμε αν το υπόλοιπο απόθεμα (stock) είναι αρκέτο ώστε ο χρήστης να προσθέσει την ποσότητα προϊόντος που επιθυμεί.Αν δεν υπάρχει stock, εμφανίζεται το ανάλογο μήνυμα. Αποθηκεύουμε  στο users_total_price και users_items ,τα οποία δημιουργήθηκαν παράλληλα με τη σύνοδο (create_session), την τελική τιμη του καλαθιού στο users_total_price και το ID και το quantity στο users_items αντίστοιχα. Ύστερα από κάθε προσθήκη προϊόντος, εμφανίζεται στον χρήστη το καλάθι του καθώς και η συνολική αξία του καλαθιού.Τέλος, στην περίπτωση μη αποδεκτής εισαγωγής δεδομένων απο τον χρήστη επιστρέφεται ανάλογο μήνυμα.

• Εμφάνιση καλαθιού)

Αποθηκεύουμε στην μεταβλητή uid τον κωδικό της συνοδού ο οποίος μας δίνεται από το JSON data ως header και καλούμε τη συνάρτηση is_session_valid με παράμετρο την μεταβλητή uid η οποία ελέγχει αν η συνοδός είναι έγκυρη.Αν η συνοδός δεν είναι έγκυρη, επιστρέφεται στον χρήστη μήνυμα λάθους.Αν είναι έγκυρη, κάνουμε αναζήτηση στο users_items με παράμετρο το uid για να βρούμε το τρέχον καλάθι του χρήστη και αν δεν υπάρχει τοτε εμφανίζεται μήνυμα λάθους.Αν το καλάθι του χρήστη είναι άδειο,εμφανίζεται το ανάλογο μήνυμα. Αν υπάρχει εμφανίζεται στον χρήστη το τρέχον καλάθι του καθώς και η συνολική αξία του καλαθιού.Τέλος, στην περίπτωση μη αποδεκτής εισαγωγής δεδομένων απο τον χρήστη επιστρέφεται ανάλογο μήνυμα.

• Διαγραφή προϊοντος από το  καλάθι)

Αποθηκεύουμε στην μεταβλητή uid τον κωδικό της συνοδού ο οποίος μας δίνεται από το JSON data ως header και καλούμε τη συνάρτηση is_session_valid με παράμετρο την μεταβλητή uid η οποία ελέγχει αν η συνοδός είναι έγκυρη.Αν η συνοδός δεν είναι έγκυρη, επιστρέφεται στον χρήστη μήνυμα λάθους.Αν είναι έγκυρη, κάνουμε αναζήτηση στην βάση για να βρούμε το προϊόν του χρήστη βάσει ID και αν δεν υπάρχει τοτε εμφανίζεται μήνυμα λάθους.Αν υπάρχει, κάνουμε αναζήτηστη στο καλάθι του χρήστη users_items[uid] για να βρούμε το αντίστοιχο προϊον.Αν δεν υπάρχει στο καλάθι, εμφανίζεται μήνυμα λάθους. Αν υπάρχει, αφαιρούμε από το users_items[uid] το προϊον μαζί με την αντίστοιχη quantity που είχε επιλέξει , καθώς και αφαιρούμε απο το users_total_price[uid] την τιμή του προϊόντος πολλαπλασιασμένη με την ποσότητα.Αν το καλάθι του χρήστη είναι άδειο,εμφανίζεται το ανάλογο μήνυμα.Ύστερα εμφανίζεται στον χρήστη το καλάθι του καθώς και η συνολική αξία του καλαθιού.Τέλος, στην περίπτωση μη αποδεκτής εισαγωγής δεδομένων απο τον χρήστη επιστρέφεται ανάλογο μήνυμα.

• Αγορα προιοντων)

Αποθηκεύουμε στην μεταβλητή uid τον κωδικό της συνοδού ο οποίος μας δίνεται από το JSON data ως header και καλούμε τη συνάρτηση is_session_valid με παράμετρο την μεταβλητή uid η οποία ελέγχει αν η συνοδός είναι έγκυρη.Αν η συνοδός δεν είναι έγκυρη, επιστρέφεται στον χρήστη μήνυμα λάθους.Αν το καλάθι του χρήστη είναι άδειο,εμφανίζεται το ανάλογο μήνυμα.Αν αριθμός της κάρτας που εισήγαγε ο χρήστης δεν είναι ακέραιος και δεν αποτελείται απο 16 ψηφία, εμφανίζεται μήνυμα λάθους.Στη συνέχεια προσθέτουμε στο this_cart κάθε προϊόν που υπάρχει στο καλάθι του χρήστη και την τελική τιμή του καλαθιού, ενώ παράλληλα αφαιρούμε από την βάση την ποσότητα του προϊόντος την οποία αγόρασε ο χρήστης.Επίσης αποθηκέυουμε στο old_order τις προηγούμενες παρραγελίες του χρήστη σύμφωνα με τη βάση και ενημερώνουμε τη βάση προσθέτοντας την παραγγελια.Ύστερα εμφανίζεται στον χρήστη το καλάθι του καθώς και η συνολική αξία του καλαθιού.Τέλος, στην περίπτωση μη αποδεκτής εισαγωγής δεδομένων απο τον χρήστη επιστρέφεται ανάλογο μήνυμα.

• Εμφάνιση Ιστορικό Παραγγελιών)

Αποθηκεύουμε στην μεταβλητή uid τον κωδικό της συνοδού ο οποίος μας δίνεται από το JSON data ως header και καλούμε τη συνάρτηση is_session_valid με παράμετρο την μεταβλητή uid η οποία ελέγχει αν η συνοδός είναι έγκυρη.Αν η συνοδός δεν είναι έγκυρη, επιστρέφεται στον χρήστη μήνυμα λάθους.Αν είναι έγκυρη, κάνουμε αναζήτηση στη βάση τον χρήστη βάσει email και αποθηκεύουμε στην history το ιστορικό παραγγελιών.Αν ειναι άδειο επιστρέφεται το ανάλογο μήνυμα, αλλιως επιστρέφεται στον χρήστη όλες οι παραγγελίες του και η συνολική αξία της κάθε μίας.Τέλος, στην περίπτωση μη αποδεκτής εισαγωγής δεδομένων απο τον χρήστη επιστρέφεται ανάλογο μήνυμα.

• ΕΡΩΤΗΜΑ 9)

Αποθηκεύουμε στην μεταβλητή uid τον κωδικό της συνοδού ο οποίος μας δίνεται από το JSON data ως header και καλούμε τη συνάρτηση is_session_valid με παράμετρο την μεταβλητή uid η οποία ελέγχει αν η συνοδός είναι έγκυρη.Αν η συνοδός δεν είναι έγκυρη, επιστρέφεται στον χρήστη μήνυμα λάθους.Αν είναι έγκυρη, κάνουμε αναζήτηση στη βάση τον χρήστη βάσει email και διαγράφουμε οριστικά τα στοιχεία του χρήστη (users.delete_one(usEx).




# # DOCKER 

Στο λειτουργικό σύστημα ubuntu κάναμε εγκατάσταση του docker εκτελόντας τις παρακάτω εντολές:

```
1. sudo apt-get update
2. sudo apt install -y apt-transport-https ca-certificates curl
software-properties-common
3. curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key
add -
4. sudo add-apt-repository -y "deb [arch=amd64]
https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
5. sudo apt-get update
6. sudo apt install docker-ce

```
Δημιουργήσαμε το ακόλουθο image:
```
1. Για να κάνουμε pull το image από το Docker Hub:
(sudo) docker pull mongo
2. Για να κάνουμε deploy το image για πρώτη φορά:
(sudo) docker run -d -p 27017:27017 --name mongodb mongo
```
Από τα δεδομένα της βάσης μας (users και products):
```
1. Κάνουμε copy τα δεδομένα από τον host στο container:
sudo docker cp prod.json mongodb:/prod.json
sudo docker cp users.json mongodb:/users.json
2. Εκτελούμε την εντολή:
sudo docker exec -it mongodb mongoimport --db=DSMarket --collection=Users --file=users.json
sudo docker exec -it mongodb mongoimport --db=DSMarket --collection=Products --file=prod.json

```
Docker compose
```
● Εγκατάσταση σε Linux:
1. sudo curl -L https://github.com/docker/compose/releases/download/1.21.2/docker-compose-`uname
-s`-`uname -m` -o /usr/local/bin/docker-compose
2. sudo chmod +x /usr/local/bin/docker-compose
```



Δημιουργήσαμε το docker-compose:
```
version: '2'
services:
  mongodb:
    image: mongo
    restart: always
    container_name: mongodb 
    ports:
    - 27017:27017
    volumes:
    - ./mongodb/data:/data/db 
  flask-service:
    build:
      context: ./flask 
    restart: always 
    container_name: flask 
    depends_on: 
      - mongodb
    ports:
      - 5000:5000
    environment: 
      - "MONGO_HOSTNAME=mongodb"
```
Δημιουργήσαμε το Dockerfile:
```
FROM ubuntu:18.04 
RUN apt-get update
RUN apt-get install -y python3 python3-pip 
RUN pip3 install --upgrade pip 
RUN pip3 install flask pymongo fmt
RUN mkdir /app
COPY service.py /app/service.py  
EXPOSE 5000
WORKDIR /app
ENTRYPOINT [ "python3","-u", "service.py" ]
```
Εκτέλεση Docker compose:
```
docker-compose up -d
```

To service.py δημιουργήθηκε με χρήση του προγράμματος PyCharm.

Μέσω του Postman ελέχθηκαν τα παραπάνω endpoints.

Για την εκτέλεση ενός request μέσω Postman , Συμπληρωνουμε στο url request το επιθυμητο IP και την exposed port (IP:PORT), στην άσκηση χρησιμοποιήθηκε η port 5000.







